#include <print>

#include "Config.hpp"
#include "FredEmmott/CompressedEmbed/InputResource.hpp"
#include "FredEmmott/CompressedEmbed/StoredResources.hpp"
#include "FredEmmott/CompressedEmbed/Win32Backend.hpp"

using namespace FredEmmott::CompressedEmbed;

struct FileDeleter {
  static void operator()(std::FILE* f) {
    std::fclose(f);
  }
};
using unique_FILE = std::unique_ptr<std::FILE, FileDeleter>;

void write_hpp(const Config& config, const StoredResources& compressed) {
  unique_FILE uniqueFile {};
  fopen_s(std::out_ptr(uniqueFile), config.output_hpp_file.c_str(), "wb");
  const auto f = uniqueFile.get();

  std::println(f, "// {}generated by compressed-embed", "@");
  std::println(
    f,
    "#pragma once\n"
    "#include <array>\n"
    "#include <span>\n"
    "#include <string_view>");

  if (!config.output_namespace.empty()) {
    std::println(f, "namespace {}\n {{", config.output_namespace);
  }
  std::print(
    f,
    R"EOF(
class {0} {{
 private:
  static constinit std::array<std::byte, {1}> mCompressed;
  std::array<std::byte, {2}> mDecompressed;
 public:
  {0}();
)EOF",
    config.output_class_name,
    compressed.mCompressed.size(),
    compressed.mUncompressedBufferSize);

  if (config.include_singleton)
  {
    println(f, "  static const {}& Get();", config.output_class_name);
  }

  for (auto&& [name, offset, size]: compressed.mResources) {
    println(
      f,
      R"EOF(
  std::span<const std::byte, {0}> {1}() const noexcept {{
    return std::span {{ mDecompressed }}.subspan<{2}, {0}>();
  }}
  std::string_view {1}AsStringView() const noexcept {{
    return {{ reinterpret_cast<const char*>(mDecompressed.data() + {2}), {0} }};
  }}
)EOF",
      size,
      name,
      offset,
      compressed.mUncompressedBufferSize);
  }

  std::println(f, "}};");

  if (!config.output_namespace.empty()) {
    std::println(f, "}} // namespace {}", config.output_namespace);
  }
  std::println("Wrote header: {}", config.output_hpp_file);
}

void write_cpp(const Config& config, const StoredResources& compressed) {
  unique_FILE uniqueFile {};
  fopen_s(std::out_ptr(uniqueFile), config.output_cpp_file.c_str(), "wb");
  const auto f = uniqueFile.get();

  std::println(f, "// {}generated by compressed-embed", "@");
  std::println(
    f,
    "#include \"{}\"",
    std::filesystem::weakly_canonical(
      std::filesystem::path(config.output_hpp_file))
      .generic_string());
  std::println(f, "#include <FredEmmott/CompressedEmbed/Backend.hpp>");

  switch (config.backend) {
    case Backend::Win32_LZMS:
      std::println(f, "#include <FredEmmott/CompressedEmbed/Win32Backend.hpp>");
      std::println(
        f,
        "using Backend = "
        "FredEmmott::CompressedEmbed::Win32Backend<COMPRESS_ALGORITHM_LZMS>;");
      break;
    case Backend::Win32_MSZIP:
      std::println(f, "#include <FredEmmott/CompressedEmbed/Win32Backend.hpp>");
      std::println(
        f,
        "using Backend = "
        "FredEmmott::CompressedEmbed::Win32Backend<COMPRESS_ALGORITHM_MSZIP>;");
      break;
  }
  std::println(
    f, "static_assert(FredEmmott::CompressedEmbed::Backend<Backend>);");

  std::println(f, "#include <bit>");

  if (!config.output_namespace.empty()) {
    std::println(f, "namespace {}\n {{", config.output_namespace);
  }
  std::println(
    f,
    "{0}::{0}() {{\n"
    "  const auto decompressed = Backend::decompress(mCompressed);\n"
    "  std::ranges::copy(decompressed, mDecompressed.begin());\n"
    "}}",
    config.output_class_name);
  std::print(
    f,
    "constinit std::array<std::byte, {0}> {1}::mCompressed =\n"
    "  std::bit_cast<std::array<std::byte, {0}>>(\n"
    "    std::array<unsigned char, {0}>{{\n      ",
    compressed.mCompressed.size(),
    config.output_class_name);
  std::size_t count = 0;
  for (auto&& byte: compressed.mCompressed) {
    std::print(
      f,
      "0x{:02x},{}",
      std::bit_cast<uint8_t>(byte),
      (++count % 8) == 0 ? "\n      " : " ");
  }
  std::println(f, "}});");

  std::println(
    f,
    "const {0}& {0}::Get() {{ static const {0} instance; return instance; }}",
    config.output_class_name);

  if (!config.output_namespace.empty()) {
    std::println(f, "}} // namespace {}", config.output_namespace);
  }

  std::println("Wrote source: {}", config.output_cpp_file);
}

int main(int argc, char** argv) {
  if (argc != 2) {
    std::println(stderr, "Usage: {} <CONFIG.JSON>", argv[0]);
    return EXIT_FAILURE;
  }

  auto json = glz::file_to_buffer(argv[1]);
  const auto config = glz::read_json<Config>(json);
  if (!config) {
    std::println(
      stderr,
      "Failed to parse config file:\n{}",
      glz::format_error(config.error(), json));
    return EXIT_FAILURE;
  }

  if (
    config->output_class_name.empty() || config->output_cpp_file.empty()
    || config->output_hpp_file.empty() || config->input_files.empty()) {
    std::println(
      stderr,
      "output_class_name, output_cpp_file, output_hpp_file, and input_files "
      "are required");
    return EXIT_FAILURE;
  }

  std::vector<std::vector<std::byte>> inputBuffers;
  std::vector<InputResource> input;
  inputBuffers.reserve(config->input_files.size());
  input.reserve(config->input_files.size());
  for (auto&& [name, path]: config->input_files) {
    const auto data = glz::file_to_buffer(path);
    if (data.empty()) {
      std::println(stderr, "Couldn't read data from {}", path);
      return EXIT_FAILURE;
    }
    inputBuffers.emplace_back(
      reinterpret_cast<const std::byte*>(data.data()),
      reinterpret_cast<const std::byte*>(data.data() + data.size()));
    input.emplace_back(name, inputBuffers.back());
  }

  StoredResources compressed {};
  switch (config->backend) {
    case Backend::Win32_LZMS:
      compressed = Win32LZMSBackend::compress(input);
      if (
        Win32LZMSBackend::decompress(compressed.mCompressed).size()
        != compressed.mUncompressedBufferSize) {
      }
      break;
    case Backend::Win32_MSZIP:
      compressed = Win32MSZIPBackend::compress(input);
      break;
    default:
      std::println(
        stderr, "Unknown backend: {}", std::to_underlying(config->backend));
      return EXIT_FAILURE;
  }

  std::filesystem::create_directories(
    std::filesystem::path(config->output_cpp_file).parent_path());
  std::filesystem::create_directories(
    std::filesystem::path(config->output_hpp_file).parent_path());

  write_hpp(*config, compressed);
  write_cpp(*config, compressed);
  return EXIT_SUCCESS;
}